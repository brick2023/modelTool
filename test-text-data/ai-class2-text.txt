那這邊接下來就會有一個問題就是我們要拿哪些語言模型串在一起還有每個語言模型它的輸出的答案去給那個驗證的模組看過以後要分數小於多少才丟給下一個語言模型呢?在這篇paper裡面他把剛才講的那個問題看作是一個最佳化的問題這 個問題它的敘述是這個樣子的那這邊有一些數學式讓你覺得這篇文章比較有學問一點這個數學式如果你 沒有辦法看得很懂的話其實也不影響你對這篇文章的理解他是這樣說的假設我們有一個語言模型叫作Li 它的輸入叫作Q它的輸出叫作Li of Q這邊是一些符號的定義R of A, Li of Q這個Li of Q是模型的輸出A我們當作是正確答案那這個A呢跟模型的輸出相比較的結果代表這個模型在這個問題上得到的效果,得到 的performance比如說正確率當然不同的任務你可能評估的標準不太一樣也不是所有的任務都用正確率來評估那這個S of Q, Li of Q呢代表的是剛才那個驗證模組它輸出的分數你又把這個輸入的問題跟輸出的答案丟給驗證模組它會輸出一個分數代表說這個驗證模組覺得這個答案是對的的信心有多少然後呢每次 你去呼叫一次Language Model Li的時候你要花的錢是多少呢根據這個以下這個公式來計算因為我們剛才有講過說每一次你呼叫一個線上的API的時候你的花錢是分成三個面向來討論的第一個面向是輸入的分數第二個面向是輸出的分數三個面向來討論的第一個面向是輸入的長度那這邊用Q的這個Qnone來代表Q呢輸入的問題的長度所以輸入的問題的長度加上這個輸出的答案的長度再加上有時候你不管輸入輸出多長那 個API到Sony一點錢所以要加上一個長數那輸入的長度前面要成一個長數項輸出的長度要前面要成一個長數項最後再加上另外一個長數項這三個長數項不同的線上的API那個數字呢都是不一樣的好那接下來呢找哪些模型放在Cascade的那個Pipeline裡面還有每一個節點的FreshCard怎麼設計就變成一個Optimization的Bubble那我們現在要找到一串的語言模型假設我們今天這個Pipeline裡面最多就是K個模型所以L1到LK我們把L1跟LK串起來叫做大L然後每一個L它的輸出呢都需要有一個Threshold告訴我們說如果今天這個 驗證模組的分數小於這個Threshold才進入到下一個階段才丟給下一個語言模型所以我們有一個大T裡面 是每一個階段的ThresholdLanguage1 Language2到LanguageK-1那我們現在要解一個最佳化的方法就是我們要把L的輸出放在這個LanguageCard裡面那我們現在要解一個最佳化的問題找到一個L找到一個大T使得以下這個式子被最大化那這個式子被最大化是什麼意思呢這個式子是Summation over某一個任務裡面所 有的問題然後呢你把所有的問題通通丟到這個Pipeline裡面然後呢讓這個Pipeline給你一個答案然後再 跟正確的答案做比對把所有問題從這個Pipeline裡面得到的分數加總起來你希望它越大越好你希望透過 設計這個L找一串的語言模型設計這個Tile找一串的Threshold讓你最後模型的輸出的結果越好讓你最後 模型輸出的結果越正確越好那這個Lz of Q這個下標Z是什麼意思呢就是在語言模型裡面哪一個語言模型 最終被執行拿出來得到最終的答案那哪一個語言模型最終會被執行呢第一個它的第一個在這一串的模型 裡面第一個它得到的驗證分數可以大過它對應的Threshold的那個模型會被執行所以這個Z是怎麼找出來 的呢你就窮取所有的下標從1、2、1、4到K然後看說哪一個I最先可以讓驗證模組得到的分數大過Threshold那個I就是我們這邊的Z然後接下來呢你還要考慮一下你花的Budget假設你全部可以花的錢叫做大B那你先算一下把這整個Compass裡面所有的問題都跑完你到底需要花上多少錢呢那你就把每一個問題會執行多少的語言模型先加總起來這邊是I等於1到Z這個Z就代表你跑了幾個語言模型接下來把每一個語言模型它 需要花費的Cost每一次Request這個語言模型需要花費的Cost把它加總起來這邊有一個Contract這個Contract是你把所有的結果最重要小於你的Budget小於大B然後呢你就是要找一串語言模型找一串Threshold 然後滿足下面的限制滿足這個條件的限制然後最佳化最大化你模型得到的結果解這個問題你就可以找到 一組最好的語言模型找到一組最好的Threshold那這邊的結果了這個Frugal GPT試了三個不同的任務第一個是Headline第二個是OverrulingOverruling好像就是給一個法律的條文然後判斷說這個法律的條文有 沒有蓋過其他的法律的條文最後就是做一個QA的問題總之就是做三個問題那這三個圖上的縱軸都是正確 率橫軸都是所花的錢那紅色的這一條線呢是Frugal GPT他在可以使用不同Budget的情況下可以得到的正 確率那在看Frugal GPT之前我們先來看看其他模型的表現我們先來看縱軸一般我們都會覺得GPT-4應該是最強的模型但有趣的地方是在COPQA這個Code本上其實GPT-3居然是比GPT-4還要強的GPT-4看起來比J1又 還要再弱一點所以GPT-4原來他也有不擅長的事情也有些任務也許GPT-4沒有比別的模型做得更好再來我 們看橫軸所要花的錢基本上GPT-4都是最貴的但是第二名就有一些差異了比如說在COPQA上第二名是GPT-3但是在這個Headline上面第二名就是J1所以這任務本身特性的不同所以不同的模型他需要花的錢其實也 是不一樣的因為有的模型是輸入場花比較多錢有的模型是輸出場花比較多錢所以不同模型在不同任務上 他需要花的錢也是不一樣的那最後呢如果你看這個Fugo GPT在同樣的Cost下面他基本上都會比同樣Cost 的所有模型表現還要更好那如果是跟GPT-4來比你會發現說舉例來說在看Headline這個例子他可以花遠比GPT-4好的錢少的錢就得到比GPT-4更好的結果我看COPQA這個例子他在花一點點錢的情況下就可以跟GPT-4一樣好然後GPT-3在這個例子裡面最好的但他可以花比GPT-3更少的錢才能得到跟GPT-3一樣好的結果好 所以這個就是Fugo GPT給大家介紹一下看看窮人是怎麼使用線上的API的
