# -*- coding: utf-8 -*-
"""
與搜尋相關的函式
"""

from fuzzywuzzy import fuzz, process

def fuzzy_search(query, data):
    """
    這個函式會回傳一個 list，裡面包含了所有符合的結果的 tuple 格式為: (文本, 相似度)
    每個結果都是一個 tuple，包含了 (名稱, 相似度)
    接收兩個參數 query 和 data 分別代表使用者輸入的字串和要比對的資料
    """
    results = []
    for item in data:
        score = fuzz.ratio(query.lower(), item.lower())
        results.append((item, score))
    results.sort(key=lambda x: x[1], reverse=True) # 依照分數由高到低排序
    return results

def search2(query, data):
    """
    這個專門用來搜尋長篇文章(後還發現好像沒什麼差)
    """
    results = process.extract(query, data, scorer=fuzz.ratio, limit=10)
    return results

if __name__=='__main__':
    # 測試用數據
    data = ['test', 'apple', 'banana', 'cat', 'dog', 'egg', 'fish', 'goat', 'house', 'ice', 'juice', 'kite', 'lemon', 'mango', 'noodle', 'orange', 'peach', 'queen', 'rice', 'sugar', 'tea', 'umbrella', 'violet', 'water', 'xenon', 'yogurt', 'zebra']
    # print(search('crazy', data)) # [('apple', 80)]

    # 中文測試數據
    chinese_data = ['黃子佼近況曝光！男星說出「關鍵人名」 秒被打斷好吃好秒被打斷好吃好秒被打斷好吃好秒被打斷好吃好', '好好吃', '好開心', '好開門', '好開朗', '好開運', '好開車', '好開懷', '好開眼界', '好開心', '好開懷', '在說啥']
    print(fuzzy_search('黃子佼近', chinese_data))

    course_data1 = ['''
    各位同學大家好我們在星期一的課程大概對前面的interval scheduling相關的問題做一個總結那我們利用interval scheduling的問題然後對這個Greedy Algorithm做一個初步的介紹那我們很快的review一次Greedy Algorithm它大概怎麼去解一個問題呢它的做法其實是很簡單也很直覺的它基本上是step by step把solution都出來那在每 一個step的時候它會選擇當下看到最好的解那這個當下看到最好的解的話那必須仰仗一個我們設計好的一個criterion去選擇什麼叫做最好那這個criterion是需要特殊設計的那其實這個criterion的設計如果它符合我們如果可 以得到一些property的證明的話其實透過這樣方式的Greedy Algorithm是可以到達optimal solution的結果那怎 麼樣去證明一個Greedy Algorithm它可以到達optimal的solution呢基本上我們通常strategy有兩種那第一種的話是這個Greedy Algorithm stays ahead那它基本上它這個證法它其實比較像是從頭到尾它都用來去說明這個Greedy Algorithm在每一步在做的時候它都會超越其他的solution那所以它就一路領先然後最後完成到達結果那這是第一種證明的方法那第二種證明的方法是exchange argument這個exchange argument基本上它在Greedy Algorithm 的證明的話大概是普及率是比較高的那它基本上顧名思義它就是用交換的方式然後達到證明那怎麼交換呢它是這 樣子的我們通常都是先設定有一個人很厲害他先得到一個optimal solution但是這個optimal solution是用別的 方式不管怎麼樣它去產生的那接下來的話因為這個是用別的方式去產生的一個optimal solution所以勢必它在當 中這個solution的組成當中它勢必有一些部分是不符合我們當初設計的Greedy rule那不符合我們的criterion的 選擇方式那所以這個exchange argument它做的事情就是把那些不符合Greedy rule選擇方式的部分把它挑出來 砍掉砍掉之後換成用Greedy Algorithm選擇的方式得到的解把它貼回去那貼回去之後那我們就要去說明貼回去之後 這個砍掉貼回去這個就等於是做一個交換的這個動作每做一次交換基本上我們要證明的是說每做一次交換其實這 個solution還是feasible 還是合理的解還是合理的解 這是第一要件那第二要件是這樣子交換了之後他的solution quality並不會變差並不會變差那所以透過這兩個因為我們改了之後其實這個solution是合理的而且solution quality又是可以維持的那原來我們已經說這個solution是別人找到的最佳解那透過我們這樣的改變又沒有損失他 的solution quality那當然我們就可以說那我就其實是可以把它改成一個Greedy algorithm得到optimal的解那這樣就證完了那這個是一般Greedy algorithm要證明最佳解的兩種strategy那在接下來這一個章節課程的話我們要 介紹兩大非常有名的問題那這兩大非常有名的問題我想其實很多同學在其他課程多多少少大概都有所接觸那但是 我們這邊的話是以algorithm的角度來去介紹他好 第一個是shortest path那shortest path的問題其實有很多種 版本那但是在這個章節我們介紹的是其中第一個最簡單的版本那這個shortest path的版本那他所衍生的這個solution大概是在1959年的時候Dijkstra發展出來的那Dijkstra是一個非常有趣的我覺得他比較像是數學家那他的版 書寫得非常好那他筆記也做得非常棒所以基本上其實他這輩子做的研究其實他都是寫在紙上的比較多然後他大概 都會編好然後第幾頁這樣子那他其實在當初在提出這個方法的時候其實在大約同一個時間有另外一個學者叫Prime那Prime其實也對另外一個問題也提出了一個solution那這個Dijkstra當初在提這個solution的時候其實他是在一個paper上面提了一個algorithm解了兩個問題解了兩個問題那這是其中一個問題就是他解了shortest path的algorithmshortest path的問題那其實他在同一篇paper就說明其實他這個方法也可以解決另外一個問題那另外一個問題是minimum spanning tree那也就是我們這個問題介紹完之後我們接下來會介紹minimum spanning tree那但是 呢因為Prime其實他就單對minimum spanning tree提出了一套方法其實Prime的方法跟Dijkstra的方法是共通的是相同的那後來後人就是在歸類這個貢獻的時候那就把shortest path的這個版本歸功於Dijkstra的貢獻那所以他之後設計出來這個演算法我們就叫Dijkstra's algorithm那但是其實minimum spanning tree的那個方法跟Dijkstra的方法非常類似本質上是相同那只有一個地方小不同而已那那個版本的algorithm那我們就歸類於Prime的貢獻所 以那個algorithm就叫Prime's algorithm好 那之後我們會看到那我們先看一下為什麼會有shortest path的問題 呢這其實還就是日常生活中也滿常發生的對不對那Dijkstra其實他是一個還滿有趣的學者那他其實他在1972年非 常早的時候就拿到數學就是數學這邊的諾貝爾獎就是Turing award那這個Turing基本上也是一個數學家他是一個 英國的數學家那之後有機會我們再提到他好 那這個Dijkstra曾經他在那時候得到Turing award的時候通常Turing award得主當年就是得獎當年他必須要發表一個得獎演說那通常這些得主他的演說通常都非常有名氣那其實大家 也都可以去Google search一下基本上每一年的那些lecture的他的那個就是講稿基本上在網路上大部分都是可以 找到的那他曾經在他那一年得獎的時候他就提到寫程式就是有一些很重要的事情那他大概基本上就是他建議就是 在寫程式的時候其實我們會發現寫程式通常大家歷經的過程就是打開電腦然後就開始寫然後接下來第一個版本的 程式大概通常很快就寫完然後接下來就落入無盡的debug的時間然後一直到做完為止那如果其實你的程式寫得很好假設運氣都非常好然後寫得也都非常認真的話基本上你的程式可能是沒有bug那所以基本上在這樣的狀況你的程式大概很快就解決了那但是大家很多人今天大家都是你可能花了一整個晚上去debug最後基本上發現你的bug就是一 個很小的錯誤那但是沒辦法你還是就是要花這麼多時間去找他那其實他的建議就是最有效的effective的那個progression方式就是不要讓bug產生在你的程式裡面那所以其實他是側重在一開始你再去設計這個procedure的時候他在logically上面他就必須要是perfectly就是完美的那這樣子你再去implement他的時候比較不會出現這個logical上的一些錯誤然後最後產生一些無法預期的bug好 那這其實休息test很常用那基本上其實大家現在也很常用google map那就比如說我現在要到達一個餐廳然後去參加聚餐然後怎麼從交大出發到達那個地方我們大家也常常去用google map去設局一下那我要走哪一條路線會比較好然後或是在車子裡面大概有些是內建那有些是另外買的那會有一些GPS的定位系統那大概也是可以就是幫你找到合適的路徑那這其實大部分的話都是找尋兩點之間的最短路徑就是為他主要的這個功能那當然以開車而言的話大家現在大概還有很多option比如說你可以去找油耗量最少的然後 或是所花時間最短的然後或者是實際走的路程是最短的其實他會有不一樣的solution那現在的話大家也會動態加 入一些就是路程上一些資訊比如說這條路平常塞不塞車比如說上下班的時候光復路塞得很嚴重那所以如果你開車 走光復路基本上你所需要的時間就會比原來預期的還要長很多那他就會把這些加進去那這就是一些演算法的一些 變形那另外其實這個shortest path hours也常發生在就是shopping mall裡面而台灣好像比較沒有這種interactive的就是show你怎麼樣去找到那間店基本上就是假設一個shopping mall很大的話你要找到一個specific的某一間店其實不是那麼容易那有一些那個floor guide你可以到那前面你就可以直接輸入你要去哪一間店然後那基本上他會show你要怎麼樣去找到他這基本上也是一個shortest path演算法的一個展現好 那接下來的話我們就來實際來 看一下這個shortest path algorithm他所要解的問題是什麼呢那這邊的話我們先看第一個版本的shortest path 的問題那input是什麼 是一個graph那在這個graph上面他特別強制說是一個directed graph那既然是directed graph的話就表示這個edge是有方向性的那大家可能會說那undirected graph怎麼辦呢那你可以想像undirected graph就是一條edge他有兩個方向那你就可以 也可以把它延伸變成是undirected graph的版本好 那在這input當中有幾件事情是比較特殊的第一個 第一個他是一個undirected graph然後另外在跟之前的所有的directed graph或undirected graph不一樣的地方是我們今天所考慮的這個directed graph上面的edge是有weight的edge是有weight 是有一個比重那在這個shortest path的problem當中這個edge呢 這個edge代表的是距離那舉例來說那一般來講我們使用shortest pathalgorithm的problem的時候是這樣子的就是基本上在這個directed graph當中這些點代表的可能是某些地點然後或一些 比如說或者是某些building然後這些edge通常代表的是某一條路就是一小段路然後那上面附的這個數字通常代表的就是這兩個building兩個location之間的距離那通常代表的是距離那當然你也可以 把他稍微改一下變成是說你開車從就是這兩點之間開車所需要花的時間然後或者是你也可以把他想成是就是這兩 點之間就是到達對方所需要花的cost比如說兩個城市之間的機票錢有多少那你也可以用這樣的方式去model他那我們今天先想一下就是最簡單形式的就是距離好 那接下來的話呢那這個shortest path probleminput是一個directed graph那上面呢有點有限那這edge代表的是距離那接下來他還另外會給定一個起始點source起始點source s那 所以這個版本我們也叫做single source shortest paths s s psingle source shortest path problem那他的目標是什麼呢他的目標就是請你幫忙找到從這個source點出發到達剩下所有的點的最短距離好 那這是single source shortest pathproblem的目標那在這邊的話呢我們另外再提一下就是那什麼叫做path路徑的長度呢那通常一般 來說這個路徑的長度就是看這條路徑上面所經過的edge上面的距離的總和這也很容易理解好 那我們這邊稍微再附帶一題為什麼他最後這個目標變成其實是single source shortest path意思是說他其實只要給定起點然後但是他並沒有限制終點那我們一般日常生活中我們可能會需要用的是有起點有終點因為我們大概就是單一時間我只需要 知道到達某一個目的地他所需要的所需要走的路徑應該是怎麼走就行了那但是為什麼他放他relax掉這個目的地這個條件呢主要原因是因為其實這個Dijkstra的這個algorithm他發展了之後呢 他最後發現其實他的這個algorithm並不僅止於可以突出兩點之間最短距離他其實可以突出來的是起點到達剩下所有點的最短距離 他都可以做到所以後來他就發現其實他這個問題來講的話他並不需要給定終點那所以他就所以這個問題就因為這樣而稍微有點改變 了好 那這邊的話其實是有一個動畫基本上這個大家可以稍微看一下那以這個例子來說的話他大概就是從A點開始 出發那他想要算就是到達剩下各點的最短距離那這個動畫的話就是其實可以透過下面這個連結可以找到那等一下 我們會用一個step by step的例子來去demonstrate怎麼去做這件事情好 Dijkstra那我們直接介紹Dijkstra's algorithmDijkstra's algorithm他的他的這個基本精神是greedy algorithm那做起來其實非常簡單那我們先講一下這個Dijkstra's algorithm他怎麼去做他的他是這樣子這個Dijkstra's algorithm當然input一定會有一個給定的一個directed graph那另外呢這個LL是一個length function就是每一條edge上面對應的長度對應的距離那等一下在這個procedure當中的話有兩點是要特別注意的我們要特別去maintain他的第一個是大S的這個set那第二個是每一個點都會有一個d value那什麼叫大S的這個set呢大S的這個set裡面存的就是我已經算完的我已經算好從起點開始出發到達這個點的最短距離如果已經算好的話我就會把它放到S這個set裡面那當然最終目標呢基本上應該是所 有的點呢都會放到S裡面大S這個set裡面呢就表示這個algorithm就結束了那第二個呢其實在這個procedure當中最重要的就是每一個點呢其實我會maintain一個d value那這個d value呢基本上目的就是要去存這個從source點到 這一點的最短距離的值最短距離的值那這叫d value每一個點都會有一個那接下來他這個procedure很簡單因為他 是一個規定algorithm所以他其實會是一個iterativeiterativealgorithm的形式那給定起點是S那所以基本上我一定是從S開始出發那這下面是一個小圖啦那這邊的話是directed graph然後我想要從S開始出發他basic idea是這 樣那我就從S開始出發的話呢大概有幾點一開始就可以確定的第一個呢是S這個點呢我一定會知道從S到S本身自己 走到自己當然是零距離因為我一開始就站在出發點上那出發點到出發點那當然是直接就是相同點所以是零距離這 是我一開始就可以知道的所以一開始的話呢我就可以先把起點source放到大S這個set裡面那另外呢起點的這個d value當然是自己到自己零距離所以一開始我也可以設定他的d value為零這是一開始就設定好的那接下來不知道的是剩下人的d value應該要怎麼樣去得到那怎麼去得到就透過一個while loop來去計算他那他是一個greedy algorithm他greedy algorithm運作的想法是這樣子的他就從起點開始出發之後在每個iteration每個iteration他去找 尋的就是從大S目前maintain這個大S已經算好的這些最短距離的這些點裡面呢開始看一下這些人有沒有目前可以 到達reach到的最近的新的點那從這裡面找到一個這個可以reach到的最靠近的新的點把他找出來那找出來之後呢 就確定我就走過去那確定了之後我就把這個點就放到大S的這個set裡面那並且呢我就定義這時候呢我就確認他的d value就是最終的最短距離就不再改變了基本上是這樣做的那所以在這邊的話呢我們來看一下這裡面最複雜的大 概就是第三行跟第四行其實第三行和第四行是同一句話那但是因為稍微複雜一點所以我把它稍微拆開來看那主要 是因為第四行的這個式子他是這樣子所以他在每個iteration當中他都去選擇目前從大S這些點裡面往外看出去可 以reach到的最近的點那這個最近呢要用什麼觀點來去看那當然是要看是從source端出發目前可以reach到的最近 的點所以他的算法是這樣這個minima取的是所有人的minima那這個後面呢我想這邊可以稍微把它做好一點是這邊 請大家幫忙加一個括號因為這加起來是一個turn加起來是一個turn這是比較有意思的好 那他是這樣子的他基本上要算呢就是假設呢我從S大S的某一個點開始出發那大S裡面的每一個點身上的dvalue我是目前已經確認就是從source端到大S裡面任何一個點的短距離我已經知道了那從這一點呢透過一條edge走出去可以reach到新的點那這一點 呢那這個距離把它加起來之後加起來總和是最小的總和是最小的那一點呢我就把它選出來那假設那一點叫做V點叫做V點那我就把它選出來那一點選出來之後基本上我就認定呢其實這個V點的最短距離我就確認了那我就確認了那 所以接下來要做的事情就是把V點放到大S這個set裡面而且並且把V點的這個dvalue呢就直接設定確認就是剛剛算 出來的這個值那這是主要每一個iteration最重要的步子要做的事情就是這樣那他就iteratively這樣做那直到所 有的點都已經算完為止然後就停下來那或者是說呢就是如果他這個directed graph比較特別就是edge不能真的reach到所有人的話呢就是他會做到他再也走不下去為止然後就會停下來好 那這邊是一個小例子好 那一開始的話呢 假設這是一個directed graph那source點在這個地方那這個兩點之間的距離都已經給定了那這個edge是有方向性 的好 那接下來的話呢我們就來看一下往下走那怎麼做呢那基本上其實從他一開始會這樣source點是S那所以我會 知道S到S是零距離所以這時候他的dvalue是零這是我知道的然後呢 接下來呢接下來呢 他往外看出去那從第一個iteration我們可以試做看看從S往外看出去我會知道呢這個他可以往外看到U、V、X這三個點對不對因為這邊有edge這邊有edge然後呢 從這邊連出去的話呢加起來的這個d跟length加起來的長度edge的length加起來是多少呢大家會看到這個是零對不對零加一所以到U點目前我看起來我可以花一個單位的長度走到U那零加四可以花四個單位走 到X然後這邊的話零加二花兩個單位走到V花兩個單位走到V所以接下來當然一、二、四誰目前看起來是最近的呢那當然我就會選擇一這個人就是U這個點呢他的距離是一我認為這時候一、二、四比起來他當然是最小我就會選他那我就會走過去那走過去了之後呢走過去了之後這個S就長大了這時候就包含了S跟U這兩個點然後依此類推那我再update然後呢那假設啦那再繼續做的話我會繼續再做下去的話我會長到V這個點放進來那假設假設在某一個iteration的時候我們目前已經explore到目前這樣的程度那這個粉紅色陰影部分所蓋住的人是目前已經算出來確認他的最 短距離的這些點就是只有這三個點但接下來我要看看剩下的人我要怎麼樣繼續explore好 在這一刻的話我們來看 一下這時候那這時候算出來的deep prime value是多少呢我們先看一下X是多少X目前的話呢因為優點這個人的最 短距離是1對不對所以這時候往下看看出來的話1加1這個X呢目前可以算出來的deep prime value是2然後呢接下來那個這個Y點呢Y點的話基本上1加3是4然後呢這個Z點呢基本上是2加3是5好 那所以每個人的每個人透過目前的S這些人呢往wide reach出去可以到達最近的方走法呢大概是距離是2、4、5所以呢從目前這些還沒走到的這些人來講距離最近的就是X這個點所以接下去他就會他就會往X這個地方走過去X就會放到大S的這個set裡面好 放下去好 那放下去了之後呢那其實我就會確認了我就會確認X這個點的最短距離那距離X的最短距離就是2這個數字是只要放到大S這個set裡面之後呢就不會再改變他就確認了那他就不會動好 那接下來到達了X這個點之後他放進來之後接下 來呢我們就來看一下到Z的距離或到Y的距離是不是有機會可以再update他呢那基本上是有機會的因為到X目前我已經確認S到X最短距離是2了所以呢透過X到Y這條edge我發現呢其實他可以透過2加1距離總和是3的方式到達Y這個點所以Y的d' value就暫時改為3然後呢 Z的話呢是2加2等於4然後也比原來這個5還要小所以他會下降好 所以到目前到這個位置了之後接下來就3跟4來比那3比較小所以接下去大家知道接下去下一步就是把Y放進來然後最後就把Z放進來然後就整個procedure就結束了好 這邊有沒有問題好 那透過這個例子的話呢大家會看到幾件事情他這個D'Aguilera在運作的時候他大概有幾件事情是很有意思的第一件事情呢是大家一開始可以想像呢從S一開始只有S到S這一點是零距離我是可以確定的那但是剩下的呢剩下的人到底最短距離是多少你可以想像一開始像是無限大就是我 還不確定然後接下來其實在運作過程運算過程當中呢其實每個人maintain這個D'Aguilera呢D'Aguilera會不斷地 下降會不斷地下降因為透過新的explore的新的一些explore的點呢我可以得到更近的走法那所以這個D'Aguilera 會開始從無限大開始往下下降那直到他reach到他真正的最短距離之後他就再也不會改變了然後呢最後他放到大S 這個set裡面他就freeze掉就是等於我已經解決掉了那就不會再去動作了那另外一個為什麼叫Greedy Aguilera呢 基本上大家也會看到他在選擇這個我往下走的這個點的時候呢其實他選擇的方式呢他其實是按照從source點出發 然後從比較近的點開始走一直走到最遠的點走到最遠的點然後就結束那所以其實如果你看他走的路程來看的話呢 其實他是不斷地增的他的D value就是explore的點呢是從比較小的D valueexplore到比較大的D value所以他是一個漸增式的那所以在這一點來看的話他是一個Greedy的想法就是從比較近的人開始走然後一直走到比較遠的人然 後就結束了好 這邊有沒有問題好 那這個procedure呢基本上這樣講的話呢其實他是一個概念式的描述真的等到你要去寫程式的時候呢大家會遭遇到比較大的困難是如何去implement第三行跟第四行那在這邊的話呢大家會發現第三行跟第四行這邊你需要一個特殊的data structure來去配合他為什麼呢第三行和第四行我們這邊要做什麼事情 其實他這個procedure裡面大概有兩件事情你要想辦法去maintain他第一個是你一定要知道大S現在已經算過哪些 人了這是你要知道的那第二個的話呢是在每一個iteration呢你要去選擇出目前看到距離最近的點那這個點要怎麼找呢這個點要怎麼找呢那這邊的話呢又按照字面上意義的話呢你要從大S這個set裡面每個點都挑出來看看透過大S裡面的任何一個點呢往外reach看看呢往外走看看誰的距離比較小所以你可能每個人都要往下都要往外reach一次 那所以其實在每個iteration你在做checking這個動作的話他會變得很複雜所以這邊的話呢其實我們就會希望這一行呢這個第三、第四行這個在tag minima這件事情的時候可不可以很快可以突出結果這是implementation上面會 遇到的困難那到底怎麼做implementation呢我們等一下在講完證明之後我們再回來看他那但是這個procedure的話呢overall來看他的概念是很單純的他基本上就是從最近的點開始走然後一路慢慢走到比較遠的點然後就結束了那所以接下來我們要看的是這個procedure提出來之後我們就要去證明他是對的那意思是說我要去證明他算出來的結果的確呢對於每個點算最後算出final的這個d value絕對是s出發到達這一點的最短距離這個證明的方法呢因為我們通常有兩招一個是交換法然後另外一個是algorithm states ahead那這邊的話我們用的是這個greedy algorithm states ahead的方式好 那這邊的話呢其實有一個loop invariant我們想要去證明他是這樣子的其實這邊的話呢我們回來看一下這邊其實always有一個white loop那這邊我們大家可以慢慢的透過這些證明我們在這門課裡面其 實我們是這樣子的就慢慢透過這些procedure後面配合的證明大家可以慢慢的去學習到你設計好一個procedure之 後你要去怎麼去證明他的正確性像一般如果你遇到了這個procedure他如果是呈現是一個interactive的形式就是 裡面是step by step然後iteration by iteration然後做某些固定的動作那你要去證明這個procedure他是對的話呢有一個經典的做法那我們也常常在使用就是我們去證明這個loop因為他都是loop的形這個loop會具備一個不變 的property那我們叫loop invariant property然後那基本上呢這個loop invariant property證完了之後你就可 以得到final這個loop結束的時候他這個property就是always是maintained那我們希望透過這個證明最後就會證明這個property自動會導引到我所需要的結果這是loop invariant property我們通常證明的方法所以這邊我們來看一下這個procedure和loop invariant property是什麼呢 是這樣子的基本上其實我要說的就是在每個iteration 我們在這個procedure當中maintain的s這個set裡面他有一個特性我們剛剛有說這個放到s裡面set放到s這個set裡面的點呢就代表他的d value已經被確定而且不會再改變了那我要去證明這個是不變的定理這是不變的定理那我要去證明這件事情那假設如果我證明成功的話呢他會帶給我什麼好處就是如果我這個花一loop結束的時候就表示他 花一loop什麼時候會結束就是所有點都放到s這個set的時候才會結束對不對那如果我這個property成立那就是大S set裡面所有的人的d value是確定而且不會再改變的那這就表示什麼這個procedure結束的時候呢所有點的d value是確定而且不會再改變他就是正確的我要的結果那我就可以去證明這個procedurerun完的時候呢其實每個點的 最短距離我是可以確定的 是對的那這是loop invariant property為什麼要這樣做的原因好 那所以在這邊的話呢我要去證明就是不管在任何時刻大S這個set裡面呢所放的點呢他的這個d value呢就是最短距離就是我所要求的最短距離這是我要證明的那怎麼去證呢像loop invariant property因為他是一個iteratively的形式那而且full loop、花一loop這些他在做的時候他一定都是從比較小的個數開始長到比較大的個數所以呢他最適合的證明方法就 是induction 就是數學歸納法那我們就是用數學歸納法來去證那而且怎麼證呢那基本上我們就選擇induction在大S這個set裡面包含的個數那因為他概念上就是大S這個set一開始只包含source.s這個點然後他慢慢的呢就從比較 近的點開始explore那最後把所有的點都放到大S這個set裡面就結束了那所以其實他在做的時候那我們就要去證明就是當第一個點S放進來的時候是對的然後接下來呢第二個點、第三個點一直到所有點都放進來的時候這件事都是對的那我就done 就結束了那所以我們就用induction來去做他那這個induction這個proof呢通常包含兩大部分那 大家也都很熟了第一個部分通常是很簡單就是basic case一定要成立那basic step的話通常就是看最小那個那最 小就是initialinitial的時候是什麼呢initial就是S這個set裡面只包含source點一個人而已那只包含source點一個人的話呢那這個statement成不成立呢當然是成立了因為source到source自己是零距離所以我的確在當下的時候一開始的時候source點這個人的d value是零對不對那我所以這個是trivial這是對的好那接下來困難是接下來的inductive step那inductive step這邊的話呢通常我們在證明的話你就要去思考你要用weak induction還是strong induction那在這邊的話呢其實我們採用的是weak induction為什麼會這樣做主要原因是因為我們基本上在每個iteration的時候會S這個set會增加一個新的點那所以他的確是慢慢一個一個放進來因為他是呈現這種形式所以我 們用weak induction那怎麼做 大概就是我先去證明這個statement在S這個set包含k個點的時候是正確的那我要去證明當他多放一個點放入k加一個點的時候這個set還是維持這個property是正確的就是裡面的所有的人的d value都會是最終的最短距離那我要去證這件事情好 那所以這個hypothesis的話就是說這個statement大概就是在k的時候成立那這個k基本上大概是大於大於等於1的時候是會成立的那接下來我就要去check一下是不是可以透過一些討論可以得到k加一個人放進去的時候也會是對的好 那我們知道這個procedure基本上在每個iteration我要做的事 情我就是選擇一個新的點放到大S這個set裡面那選誰呢 那我就先設定一個就給他一個名字好了我就說假設我現在在這個我討論這個iteration當中我想要加入的是V這個點我想要加入的是V這個點那我們右邊有一個示意圖讓大家看一下是這樣子的在任何一個時刻我一定有maintain一個大S這個set那大S這個set裡面包含的就是我已經確認了D value那些人然後接下來我要往外再多放一個人進來那假設目前我看到大S這個set在裡面裡面有S 然後還有一些 其他人然後接下來我想像就是我假設我現在想要把V放進來那V為什麼會放進來當然是透過我剛剛這個第三行 第四行去選擇D value加這個edge的lance加起來總和是最小的那個人把他放進來那假設我是選定了V這個人好 那既然 是選定V這個人那我就想辦法先把那條edge做出來給大家看那假設那條edge是怎麼選基本上我假設前面那個人是透過U然後走到V這個人那意思是說基本上為什麼會把V放進來是因為我是透過D of U就U的D value再加上UV之間的這條edge的lance他的距離把它加進來之後產生這個V身上的這個D prime value是最小的時候我把他放進來我先假設是這樣那就表示在這時候其實這邊有一條紅色路徑對不對就是如果U這個點他的D value確認的話就表示S到U的這 個路徑我是已經找到了那我這邊就用一個就是曲線代表他這是一條路徑這個路徑我已經找到了然後再往外延伸一 條edge出來就碰到了V點然後現在我想要把V點放進來那我就把紅色這條path叫做PVP sub V P V這條path好 那目 前我們到這邊好 那接下來我要怎麼做呢接下來我要做什麼我要想要討論就是我要證明的就是想辦法告訴大家從透過這樣的方式S到V因為我現在要把V放到大S這個set我要確認這條path真的就是最短而且不會再被別人改變了好  那為了要證明這件事情的話我就先拿另外一條路徑比較就假設這個V點其實從source點出發還有別一條路徑是可以到達V的可以到達V的那我現在來討論一下不管怎麼樣透過我這樣的選擇我選的這條路絕對是最短的絕對會比別條 路還要短這是我想要做的事情好所以所以呢 那我們就繼續來講那所以這邊的話我們來看到就是其實by induction的話呢這個我現在要把V放進來對不對那我先設定他是透過U到達的那因為by induction hypothesis我會說基本上在V還沒放進來之前那所有人都已經是就S裡面所有人其實都是到達最短的那所以意思就是說呢我知道其實在這時 候S到V的這條路徑中間S到U的這一段絕對是S到U的最短路徑那這是這個一開始這個statement我就說的好 那我目 前知道這件事情好 那接下來我要想辦法做的就是另外一條然後拿另外一條path來去跟他比然後我說另外一條絕對比較差那或是頂多跟他一樣好那我就結束了好 那現在的話就是說假設這個V點身上還有別條pathS是可以透過別條path到達V點那我現在說不管這個別條path長什麼樣子絕對不會比我現在看到的還要厲害那我要這是我想要講那我們就來看一下假設有另外一條path是綠色這條就是從S出發就是經過一些人之後到達了V點 綠色這條好 那當然這 時候大家來仔細看一下就會發現其實不管怎樣在K一個iteration結束要進入K加1這個iteration的時候S這個set是包含了這些那這條path是從小S出發source點S出發經過一些人之後到達V點所以在這條路徑上面一定會在有一個點上面會從大S這個set離開然後到達了其他人身上那一定會有這個點那既然會有這個跨出去的這件事情那我就把這 個跨出去的前後這兩點特別抓出來討論那我就說基本上跨出去的這個點就是Y這個點那他前面這個人是X好 這邊可以嗎好 那接下來我們就接下來做一些討論就行了好 那這個東西做出來之後我們就開始比大小就知道了好 那接下來的話呢我們來看一下在這個DK一個iteration結束的時候大S這個set長到目前這樣大的形式小的X目前的確在大S這個set裡面表示S到X這一段距離也一定是他的最短路徑這是我確認的好 那現在我就可以argue了現在我就可以討論了我就發現那接下來這個這個到K加1這個iteration的時候為什麼我是選V這個點呢為什麼我是選V這個點主要原因是因為根據第四行那個選擇第四行的選擇是說U的d value加上UV的這個edge的長度總和是所有人裡面最小的那 既然他是最小的絕對也就會小於這個X這個人的d value加上XY之間的距離對不對這邊可以接受嗎好 那接下來其實做完了好 那我就把一些比大小把它算一下所以到了K加1這個iteration我把V放進來的時候我做了什麼事情所以把V放進來的時候基本上這邊有一條path對不對這邊有一條path他的總長度是多少他總長度多少根據我剛剛的procedure我算起來是d of V那這個d of V當然是來自於第四行算出來的d prime V就是V的d prime value然後reassign 過來的對不對那這值怎麼算這值其實基本上當然是由U這一點開始貢獻那他就是因為我已經確認U的d value是最小的了然後再加上UV之間的edge長度這兩個term的總和是overall所有人比起來是最小的那跟剛剛的比較我會知道為什麼我會選他沒有選他當然是因為這一段加起來比較短這一段加起來比較長對不對或者是跟他一樣好那所以基本 上我至少知道X的d value加上XY的距離這兩段加起來的總和那當然會大於等於這一段S到V的這一段的總和這邊有 沒有問題這邊有沒有問題好 這個小於等於算完了之後算完了對不對但是還沒有完因為我想要比較的是S到V的這條紅色的P sub V的這個pass的長度跟綠色這條S到V的這條pass的長度好 那這邊的話我會看到我剛剛算到這個地方 就已經比較大了對不對就是從S到Y這一段已經比較大那後面這一段還沒完還沒算完他對不對那後面這一段一定是 大於等於0的數字對不對一定是大於等於0的數字對不對好 那所以加了之後只會再更大對不對所以就會有一個小於等於的式子所以total上面綠色這一條的總長度按照這樣的推導就會知道上面這條綠色的總長度一定會大於等於下面這條紅色pass的總長度這邊有沒有問題所以透過這樣的討論我們就會知道所以其實基本上其實往下再推到了K加1的iteration的時候V身上記錄的這個d value的確是V點的S到V的最短距離好 那接下來我們回來討論一件事情這 個L1我們在一開始的設定是兩個地點之間的長度對不對所以在這邊我用紅色的highlight表示這兩點之間的長度我們在這個版本的時候我們討論的是大於等於0的大於等於0的好 為什麼這邊要highlight成紅色為什麼要highlight成紅色我們下面看這個procedure這個procedure他呈現什麼形式他這個procedure有一個特性是這樣這個點只要被我放到大於這個set裡面之後我就確認他的答案已經固定不會再去更改它對不對不會再去更改它那同學們不曉得會不會感覺很奇怪為什麼不需要再去更改它為什麼不需要再去更改它那當然我們透過剛剛的證明就發現其實另外別 條路總是一定會比較長對不對那為什麼別條路總是會比較長其實是based on後面這一段就前面這一段已經比較長 了那這沒話講後面這一段為什麼還可以讓他保證比較長是因為後面這一段一定要是大於等於0的才會讓他這個小於等於的式子是對的對不對為什麼這件事情會成立因為我們有一個設定就是所有點所有edge上面的這個length長度 是大於等於0的那所以這一段不管怎樣加起來總是一個非負的數字那因為這樣的緣故所以我會保證這個procedure 正在run的時候這個大S這個set裡面的點只要放進來之後我就不用再去考慮它因為他不會再被更改得更好那這是為什麼這個Duckstra這個algorithm會是對的那但是在這邊也就再強調一個事情就是所以Duckstra's algorithm為什麼會對主要原因是因為他有一個基本的設定而且他只在這樣的設定情況之下是對的所以請大家注意一下他適用時 機只有在這個graph上面的edge weight是非負的時候你才可以使用他所以如果這個edge weight上面有出現負數的話請不要使用這個algorithm 這樣會錯那他就會產生錯誤的結果那大家可能會說那如果有負數的狀況之下我要用 什麼樣的algorithm那沒有關係我們就等到dynamic programming的時候再去跟大家介紹有其他的shortest path的演算法就可以去處理非負的edge weight好 那這邊的話呢就是implementation上面一些問題那這邊的話其實因為 他其實會跟data structure的課程比較有關係那我們這邊很快帶過一下那我們在下禮拜的話其實我會請助教幫忙 請大家幫大家稍微review一下data structure的部分那後面這一塊是data structure的課程好 那這邊的話其實我們只是只講一件事情是我要怎麼樣讓第四行很快找到這個d value加上這個edge weight是最小的那個人把他identify出來呢基本上我需要一個很好的很好的一個data structure他可以把所有人身上的暫時的這個d prime的值可 以很快突出最小值出來就每個人身上都去maintain那他在這邊做的時候呢跟這個procedure寫法有點稍稍不同是這樣子我們原來的procedure在寫的時候是以大S的觀點來去看往外reach出去呢距離最近的人是誰然後但是真正在implementation的時候我們把這件事情換一個角度來去看我就把每一個點身上隨時都去記錄一下目前我知道從source點出發到達這一點的最短距離目前來看最短的這個距離是多少always maintain這樣的一個數字然後這個數字當 然一開始我不知道是多少所以我就先設定無限大因為我不知道要怎麼走過來然後接下來陸續在運算過程之中呢這 個數值是往下降往下降然後呢那最後他會到達reach到真正的最低值shortest pass the last 之後就會停下來然 後就再也不會再改變了那這邊我們會我們所需要implement是一個mean priority queue那每一個點身上都有一個d value那所以其實我們就是把所有點呢都放到這個mean priority queue裡面那一開始所有人的d value都是無限 大然後那透過我們在運算過程當中這個d value會改變會改變會update會往下降然後呢這個mean priority queue 呢如果大家implement的好的話呢基本上他可以很容易output最小值那個人出來就output is然後順便remove他是 可以很快速的那所以基本上我們大概就是採用這樣的方式那這一張投影片只是給大家參考一下就是說其實有很多 種就是很多種這個不一樣去不一樣data structure去implement這個mean priority queue有array 這個array的話呢就是大家都存在一起然後但你每次要找最少值你就要掃過要整個掃過一遍才行那他就會比較慢然後但是binary heap這個的話就是data structure的時候我們一般會上到了這個mean priority queue或是max priority queue然後這是binary形式那他是呈現一個treebinary tree的形式然後用一個sequence去記錄他那另外比較高等級的話大概是fibonacci heap那他當然速度又會再更快一些那但是這邊的話呢這邊的話基本上我們在這門課的話我們focus會在這個地方就是至少大家要會用binary heap來去implement這個mean priority queue那這邊的話是一個例子我們講完這個例子的話就是等於是dash truss一個procedure就已經完整了那這個為什麼要放這個例子主要原因是因為讓大家稍微感受一下就是在implementation上面的時候這個dash truss他的運作方式是怎麼樣那這個例子是從Coleman那本書把它剪下來看的那這邊的話他有比較detail的implementation上面一些資訊那我覺得用這個例子來 去了解他是比較容易的好initial的話這是一開始的這個directed graph然後這有很多點然後這上面edge上面有長度 有距離然後在這個運算過程當中每個圈圈 每個點裡面有一個數字這個數字就是當下紀錄的d value當下紀錄的d value所以一開始的時候source點的自己到自己他的d value是零這個東西是我一開始就確認的然後但是剩下的 人我不知道他們目前d value是怎麼樣因為我edge還走不出去所以這時候每個人一開始的這個d value都設成無限 大所以接下來一開始的話我就把這所有人所有人都maintain在一個mean priority queue裡面mean priority queue裡面那這個mean priority queue的話基本上我每次可以都叫他extract mean就是把最小值吐出來砍掉那所以這 時候一開始的話s 是零 其他人都是無限大extract mean了之後他會把s這個人吐出來所以我就從s開始做然後在這個例子當中變成黑色的話就表示說其實我現在正在處理他而且這個變成黑色這個點就是被我放到大s這個set裡面 的人大家可以這樣去看他好 那所以s放進來放到大s這個set裡面接下來extract mean了之後他會做什麼事情就是 他接下來就來看一下這個人是不是可以透過他可以去更新update其他人的d value然後所以在這邊我透過s我往外 看出去看到兩條edge然後他透過10的長度到達t所以我會看到0加10等於10這個10比原來的無限大還要好所以這個t的這個d value就下降變成10那下面y這個d value就從0加5變5然後就從無限大下降到5那剩下的我還看不到所以還沒有辦法動他所以接下來這個mean priority queue裡面就剩下這四個點了一樣extract mean 誰最小5這個人最小所以我就把他吐出來那我就處理他吐出來的意思就是他會被我放到大s這個set裡面那我就放進來那放進來之後那 接下來一樣的再從這個新看到的這個點往外reach出去看看可不可以透過他讓別人的d value再更更新那所以接下 去的話這個人是5 5加3是8所以8比這個原來的這個10還要好所以這個t點的這個d value就被我update了然後往外 看出去呢他可以reach到5加9是14所以x這一點也被我看到他可以透過14個單位就可以走到所以也比無限大好所以 也被我update了然後接下去呢這個5加2是7這個7當然也比原來無限大好所以也被我update了所以目前就走到這個 位置那走到這個位置呢大概就剩下這三個點放在mean priority queue裡面那現在一樣的是extract最小值所以7被我凸出來然後接下來就走到7一樣的 一樣看看一下這個透過7透過這個z點往外reach出去我是不是可以update別人的距離那一樣的7加6是1313比14還要好所以這個點的d value又被我update了然後接下來只剩這個點了然後這個地方8加1那是8跟13所以接下來我就選8出來然後接下來update然後呢直到最後所有人都被我確認然後就放到大S這個set裡面好 那到這邊的話其實就算完了那這個的話就到最後Dextra就會停在這個地方所以在這邊大家會看到一件 事情是在每個點每個點的d value一定是從無限大開始往下降然後降到最後一個值就再也不會動它然後呢 另外呢 大家如果看一下他這個往外explore的點的順序他會根據他的d value往上遞增比如說他就從距離0的source點開始出發接下來他就看距離是5的然後接下來看距離是7的看距離是8的所以0、5、7、8然後接下來是9所以他這個總和 的這個d value在visit的過程也是從小排到大所以他是他的greedy的方式就從比較近的走到比較遠的這是他greedy的idea那後面的這一大段大概有十幾頁的同學就是幫大家稍微複習一下priority queue的implementation那這一塊的話就是我會請助教下禮拜在討論完作業之後稍微go through一次給大家看就是這個implementation非常重要 的原因是因為後面prince aggrison也會用到他因為他們兩個本質是相同的那平常這個東西也很好用
    ''']
    course_data2 =['''這篇文章主要講述了如何在一個圖形的情境中對不同的人進行探索。它提到了一個名為BFS (Breadth First Search) 的算法，用於在圖形上搜尋不同的方向。它還提到了一個名為DFS (Depth First Search) 的算法，用於在圖形上搜尋深度。這兩種算法都是基於圖形上的路徑，並且可以在不同的情況下應用。

    在文章的最後，文章提到了一個問題：如果一個圖形中有一個循環，如果這個圖形對不同的人進行探索，是否會出現重複？這個問題涉及到圖形上的路徑。文章提到了一個方法，用於判斷是否存在重複，並且提供了一個範例，說明如何使用這個方法。

    總體而言，這篇文章探討了如何在圖形上搜尋不同的方向，並且提到了一個重要的問題：如果一個圖形對不同的人進行探索，是否會出現重複。這個問題涉及到圖形上的路徑，並且可以通過BFS和DFS算法來解決。
    ''', 'ㄐㄐ', '靠北']

    print(fuzzy_search('廣度優先搜尋', course_data2))
    print(search2('廣度優先搜尋', course_data2))
